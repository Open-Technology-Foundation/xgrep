#!/usr/bin/env bash
# xgrep - Advanced Language-Specific Grep Tool
#
# A collection of specialized grep tools that search within specific language files
# by extension and shebang detection. Utilizes ripgrep for performance when available,
# with graceful fallback to standard grep.
#
# Usage: xgrep|bashgrep|phpgrep|pygrep [options] pattern [directory]
#
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

# Lock PATH for security
PATH=/usr/local/bin:/usr/bin:/bin
export PATH

# Version constant
declare -r VERSION=1.3.0

# Program behavior variables - determined by invocation name/symlink
declare -r SCRIPT_NAME="${0##*/}"

declare -- MODE RG_TYPE

# Determine available search command
# Prefers ripgrep (rg/ripgrep) for performance, falls back to custom grep implementation
# RG_CMD can be set via environment variable to force a specific mode (for testing)
declare -- RG_CMD="${RG_CMD:-}"
if [[ -n "$RG_CMD" ]]; then
  : # Use pre-set RG_CMD from environment
elif command -v rg >/dev/null 2>&1; then
  RG_CMD=rg
elif command -v ripgrep >/dev/null 2>&1; then
  RG_CMD=ripgrep
else
  >&2 echo 'Warning: ripgrep (rg) not found. Falling back to standard grep (reduced performance).'
  >&2 echo 'For better performance, install ripgrep: https://github.com/BurntSushi/ripgrep#installation'
  RG_CMD=grep_fallback
fi

# Configure search behavior based on program invocation name
# Each symlinked name targets specific file types using ripgrep's built-in type filters
if [[ $SCRIPT_NAME == phpgrep ]]; then
  MODE=PHP
  RG_TYPE='--type=php'
elif [[ $SCRIPT_NAME == bashgrep ]]; then
  MODE=Bash
  RG_TYPE='--type=sh'
elif [[ $SCRIPT_NAME == pygrep ]]; then
  MODE=Python
  RG_TYPE='--type=py'
else
  # Default behavior for 'xgrep' - search all supported languages
  MODE='Bash/PHP/Python'
  RG_TYPE='--type=sh --type=php --type=py'
fi

# Default excluded directories - can be overridden via XGREP_EXCLUDE_DIRS environment variable
# Common directories containing build artifacts, dependencies, or temporary files
declare -a EXCLUDE_DIRS=( .venv .gudang gudang .git bak '~' temp tmp .tmp .temp .Trash-0)
[[ -z "${XGREP_EXCLUDE_DIRS:-}" ]] \
    || readarray -td' ' EXCLUDE_DIRS < <(echo -n "$XGREP_EXCLUDE_DIRS")

#=== Helper Functions ===
declare -i VERBOSE=1 DEBUG=0

# Colors
if [[ -t 1 && -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' BOLD=$'\033[1m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' BOLD='' NC=''
fi

_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  case ${FUNCNAME[1]} in
    info) prefix+=" ${CYAN}◉${NC}" ;;
    debug) prefix+=" ${BOLD}${CYAN}⦿${NC}" ;;
    warn) prefix+=" ${YELLOW}▲${NC}" ;;
    success) prefix+=" ${GREEN}✓${NC}" ;;
    error) prefix+=" ${RED}✗${NC}" ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
vecho() { ((VERBOSE)) || return 0; _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
debug() { ((DEBUG)) || return 0; >&2 _msg "$@"; }
success() { ((VERBOSE)) || return 0; >&2 _msg "$@" || return 0; }
error() { >&2 _msg "$@"; }
die() { (($# < 2)) || error "${@:2}"; exit "${1:-0}"; }
yn() {
  local -- reply
  >&2 read -r -n 1 -p "$(2>&1 warn "${1:-} y/n ")" reply
  >&2 echo
  [[ ${reply,,} == y ]]
}
noarg() {
  if (($# < 2)) || [[ ${2:0:1} == '-' ]]; then
    die 22 "Option ${1@Q} requires an argument"
  fi
}

# Cleanup function for terminal cursor restoration on exit
# Args: [exit_code] - Exit code to use (default: 0)
xcleanup() { 
  local -i exitcode=${1:-0}
  [[ -t 0 ]] && printf '\e[?25h'
  exit "$exitcode"
}
# Trap to ensure cleanup on script termination
trap 'xcleanup $?' SIGINT EXIT

# Debug utility - pretty-print variable declarations
# Args: var_names... - Names of variables to display
decp() { declare -p "$@" | sed 's/^declare -[a-z-]* //'; }

# Fallback grep implementation using find + standard grep
# Used when ripgrep is not available on the system
# Translates ripgrep options to equivalent grep/find commands
# Args: pattern directory maxdepth grep_opts...
# Returns: 0 on matches found, 1 on no matches, 2 on error
run_grep_fallback() {
  local pattern=$1
  local directory=$2
  local maxdepth=$3
  shift 3
  local -a grep_opts=("$@")
  local -i use_color=0
  local -a files=()
  
  # Determine mode filter based on program invocation name
  local -- mode_filter
  case "$SCRIPT_NAME" in
    phpgrep)  mode_filter=php ;;
    bashgrep) mode_filter=bash ;;
    pygrep)   mode_filter=python ;;
    *)        mode_filter=all ;;
  esac
  
  # Translate ripgrep options to grep equivalents
  local -a new_grep_opts=()
  for opt in "${grep_opts[@]}"; do
    case $opt in
      --color=auto) use_color=1 ;;
      --smart-case) new_grep_opts+=(-i) ;; # Approximate with case insensitive
      --type=*|--glob|--max-depth) ;; # Skip ripgrep-specific options, handled by find_matching_files
      !*/**) ;; # Skip ripgrep glob exclusions
      -*) new_grep_opts+=("$opt") ;; # Pass through other options
    esac
  done
  grep_opts=("${new_grep_opts[@]}")
  
  # Add color if requested
  ((use_color)) && [[ -t 1 ]] && grep_opts+=(--color=auto)
  
  # Debug output
  ((DEBUG)) && {
    debug "DEBUG: Fallback mode with advanced file detection"
    debug "DEBUG: mode_filter=$mode_filter"
    debug "DEBUG: grep_opts=${grep_opts[*]}"
  }
  
  # Get all matching files using robust file type detection with shebang support
  while IFS= read -r -d '' file; do
    files+=("$file")
  done < <(find_matching_files "$directory" "$mode_filter" "$maxdepth" "${EXCLUDE_DIRS[@]}" | tr '\n' '\0')
  
  # If no files found, exit early
  if ((${#files[@]} == 0)); then
    warn "No $MODE files found"
    return 1
  fi
  
  # Execute grep search on collected files
  # Use || true to prevent errexit from triggering before we capture the exit code
  local -i grep_exit_code=0
  grep -H "${grep_opts[@]}" -- "$pattern" "${files[@]}" || grep_exit_code=$?

  if ((grep_exit_code != 0)); then
    # grep returns 0=found, 1=not found, 2=error
    if ((grep_exit_code == 1)); then
      warn "No $MODE files found with pattern ${pattern@Q}"
      return 1
    else
      error "Error searching for ${pattern@Q} in $MODE files"
      return 2
    fi
  fi
  return 0
}

# Robust file type detection using extension, shebang, and MIME analysis
# Based on /ai/scripts/lib/files/filetype/filetype
# Args: filename
# Returns: bash|py|php|c|text|binary
detect_filetype() {
  local -- filename=$1

  # Determine filetype from extension (only if filename contains a dot)
  if [[ $filename == *.* ]]; then
    local -- extension="${filename##*.}"
    case "${extension,,}" in
      bash|sh)  echo bash; return 0 ;;
      py|pyw)   echo py; return 0 ;;
      php|phtml|html) echo php; return 0 ;;
      c)        echo c; return 0 ;;
      txt|text) echo text; return 0 ;;
    esac
  fi

  # If file doesn't exist, assume text
  [[ -f $filename ]] || { echo 'text'; return 0; }

  # Attempt to determine from shebang
  local first_line
  read -r first_line < "$filename" 2>/dev/null || { echo 'text'; return 0; }
  
  case "$first_line" in
    "#!/bin/bash"|"#!/usr/bin/env bash"|"#!/usr/bin/bash"|"#!/bin/sh"|"#!/usr/bin/env sh"|"#!/usr/bin/sh")
        echo bash; return 0 ;;
    "#!/usr/bin/python"*|"#!/usr/bin/env python"*)
        echo py; return 0 ;;
    "#!/usr/bin/php"|"#!/usr/bin/env php"|"<?php"*|"<?"*)
        echo php; return 0 ;;
  esac

  # Use 'file' command for MIME type analysis
  if command -v file >/dev/null 2>&1; then
    local file_mime_type
    file_mime_type=$(file -b --mime-type "$filename" 2>/dev/null)
    case "$file_mime_type" in
      text/x-shellscript) echo bash; return 0 ;;
      text/x-python)      echo py; return 0 ;;
      text/x-php)         echo php; return 0 ;;
      text/x-c)           echo c; return 0 ;;
      text/*)             echo text; return 0 ;;
    esac
  fi

  # Default to text
  echo 'text'
  return 0
}

# Find files matching the specified language type
# Args: directory mode_filter maxdepth exclude_dirs...
find_matching_files() {
  local directory=$1
  local mode_filter=$2
  local maxdepth=$3
  shift 3
  local -a exclude_dirs=("$@")
  
  local -a find_opts=()
  local -a exclude_opts=()
  
  # Set up depth options
  if ((maxdepth >= 0)); then
    find_opts+=(-maxdepth "$maxdepth")
  fi
  
  # Set up exclusion options - exclude directories within search path but not parent directories
  for exclude_dir in "${exclude_dirs[@]}"; do
    if [[ -n "$exclude_dir" ]]; then
      # Exclude paths at root level and nested levels
      exclude_opts+=(-not -path "$directory/$exclude_dir/*")
      exclude_opts+=(-not -path "$directory/*/$exclude_dir/*")
    fi
  done
  
  # Find all regular files
  find "$directory" "${find_opts[@]}" "${exclude_opts[@]}" -type f -print0 2>/dev/null | \
  while IFS= read -r -d '' file; do
    # Skip unreadable files
    [[ -r "$file" ]] || continue
    
    # Get file type
    local -- file_type
    file_type=$(detect_filetype "$file")
    
    # Check if it matches our mode filter
    case "$mode_filter" in
      bash)     [[ $file_type == bash ]] && echo "$file" ;;
      php)      [[ $file_type == php ]] && echo "$file" ;;
      python)   [[ $file_type == py ]] && echo "$file" ;;
      all)      [[ $file_type =~ ^(bash|php|py)$ ]] && echo "$file" ;;
    esac
  done
}

# Clean ripgrep options for file-based search (remove file discovery options)
# Args: rg_opts... - Array of ripgrep options to filter
# Returns: Cleaned options suitable for searching specific files
clean_rg_options_for_files() {
  local -a clean_opts=()
  local -i skip_next=0
  
  for opt in "$@"; do
    if ((skip_next)); then
      skip_next=0
      continue
    fi
    
    case "$opt" in
      --type=*|--type-not=*) ;;        # Remove type filters (we handle file detection)
      --glob|--iglob) skip_next=1 ;;   # Remove glob options and their arguments
      --glob=*|--iglob=*) ;;           # Remove glob options with embedded arguments
      --max-depth|--maxdepth) skip_next=1 ;; # Remove depth options and their arguments
      --max-depth=*|--maxdepth=*) ;;   # Remove depth options with embedded arguments
      *) clean_opts+=("$opt") ;;       # Keep all other options
    esac
  done
  
  # Add options optimized for file-based search
  clean_opts+=(--no-heading --with-filename)
  
  printf '%s\n' "${clean_opts[@]}"
}

# ----------------------------------------------------------------------------------------

# Display help and usage information
usage() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Language-Specific Grep Tool

DESCRIPTION
  Advanced grep tool that searches within specific programming language files
  using intelligent file detection (extension, shebang, MIME type). Provides
  high-performance searching with ripgrep when available, with graceful fallback
  to standard grep.

  Available Commands:
    xgrep      - Search all supported languages (Bash/PHP/Python)
    bashgrep   - Search only Bash scripts (.sh, .bash, shebangs)
    phpgrep    - Search only PHP files (.php, .phtml, shebangs)
    pygrep     - Search only Python files (.py, .pyw, shebangs)

USAGE
  $SCRIPT_NAME [OPTIONS] PATTERN [DIRECTORY]

ARGUMENTS
  PATTERN        Regular expression pattern to search for (ripgrep/grep syntax)
  DIRECTORY      Directory to search (default: current directory)

OPTIONS
  -d, --maxdepth N
                 Limit search depth to N levels (default: unlimited)
                 Example: -d 2 searches only 2 directory levels deep

  -X, --exclude-dir DIR[,...]
                 Exclude directory from search. May be used multiple times.
                 Comma-separated list supported: -X .git,.venv
                 Use -X '' to reset all exclusions
                 Current: ${EXCLUDE_DIRS[*]}

  --, --rg ...   Pass all following options directly to ripgrep
                 Example: -- --ignore-case --max-count=5

  -D, --debug    Enable debug output showing file detection and search details

  -V, --version  Display version number ($VERSION)

  --help         Display this help message

RIPGREP OPTIONS
  When ripgrep is available, you can use any ripgrep option:
    -i, --ignore-case       Case-insensitive search
    -l, --files-with-matches List only filenames with matches
    -c, --count             Show count of matches per file
    -A NUM                  Show NUM lines after match
    -B NUM                  Show NUM lines before match
    -C NUM                  Show NUM lines before and after match
    --no-heading            Don't group matches by file
    And many more (see: rg --help)

FILE DETECTION
  Files are detected using multiple methods (in order):
    1. Extension    - .sh, .bash, .py, .pyw, .php, .phtml
    2. Shebang      - #!/bin/bash, #!/usr/bin/env python, etc.
    3. MIME Type    - text/x-shellscript, text/x-python, text/x-php
    4. Content      - <?php tags for PHP files

ENVIRONMENT VARIABLES
  XGREP_EXCLUDE_DIRS    Space-separated list of directories to exclude
                        Example: export XGREP_EXCLUDE_DIRS=".git .venv build"

  RG_CMD                Force specific search mode for testing
                        Values: rg, ripgrep, grep_fallback

EXIT CODES
  0    Matches found successfully
  1    No matches found or no matching files in directory
  2    Error occurred (invalid pattern, permission denied, etc.)
  22   Invalid argument (option requires a value)

EXAMPLES
  Basic search:
    $SCRIPT_NAME "function.*main"
    $SCRIPT_NAME "import os" /usr/local/lib

  Case-insensitive search:
    $SCRIPT_NAME -i "todo" .

  List only filenames:
    $SCRIPT_NAME -l "class.*extends" src/

  Search with context:
    $SCRIPT_NAME -C 3 "error_handler" .

  Limit search depth:
    $SCRIPT_NAME -d 2 "config" /etc

  Exclude specific directories:
    $SCRIPT_NAME -X .git,.venv "debug" .

  Reset exclusions and search everywhere:
    $SCRIPT_NAME -X '' "pattern" .

  Count matches per file:
    $SCRIPT_NAME -c "TODO" src/

  Language-specific searches:
    bashgrep "function" /usr/local/bin
    phpgrep "class.*Controller" app/
    pygrep "def.*test_" tests/

  Pass options to ripgrep:
    $SCRIPT_NAME -- --max-count=1 --no-heading "error"

NOTES
  - Uses hybrid approach: comprehensive file detection + fast ripgrep search
  - Respects .gitignore when using ripgrep (use --no-ignore to override)
  - Searches both by file extension AND shebang for maximum coverage
  - Binary files are automatically excluded from search results

SEE ALSO
  $( echo 'xgrep bashgrep phpgrep pygrep ripgrep grep' | sed "s/$SCRIPT_NAME //")

PROJECT
  https://github.com/Open-Technology-Foundation/xgrep

EOT
}

# Main program entry point
# Parses command-line arguments and executes the appropriate search strategy
# Args: Command-line arguments passed to the script
main() {
  local -a rg_opts=()
  local -a rg_type_array=()
  local -a args=()
  local -i maxdepth=-1
  local -- pattern directory

  # Configure default ripgrep options for optimal user experience
  [[ -t 1 ]] && rg_opts+=("--color=auto")  # Enable colors for terminal output
  read -r -a rg_type_array <<< "$RG_TYPE"  # Split RG_TYPE safely into array
  rg_opts+=("${rg_type_array[@]}")         # Add language-specific file type filters
  rg_opts+=("--smart-case")                # Case insensitive unless pattern has uppercase
  
  (($#)) || { >&2 usage; exit 1; }

  # Parse arguments
  while (($#)); do case $1 in
    -X|--exclude-dir) noarg "$@"; shift
                      if [[ -z $1 ]]; then
                        EXCLUDE_DIRS=()
                      else 
                        readarray -td, EXCLUDE_DIRS < <(echo -n "$1")
                      fi
                      ;;
    -d|--maxdepth)    noarg "$@"; shift
                      [[ $1 =~ ^[0-9]+$ ]] || die 2 'maxdepth must be a non-negative integer'
                      maxdepth=$1 
                      ;;
    --help)           usage; exit 0 ;;
    -D|--debug)       DEBUG=1 ;;
    -V|--version)     echo "$VERSION"; exit 0 ;;
    --|--rg)          shift
                      (($#)) && rg_opts+=( "$@" );
                      break
                      ;;
    -*)               rg_opts+=("$1") ;;
    *)                args+=("$1") ;;
  esac; shift; done

  # Check number of arguments
  #shellcheck disable=SC2015
  (( ${#args[@]} == 0 || ${#args[@]} > 2 )) && {
    >&2 usage
    >&2 echo
    #shellcheck disable=SC2317
    die 1 "Invalid number of arguments. [${args[*]@Q}]"
  } || :

  # Set search pattern and directory
  pattern="${args[0]}"
  [[ -n "$pattern" ]] || die 1 'Search pattern cannot be empty.'

  directory="${args[1]:-$PWD}"
  [[ -d "$directory" ]] || die 1 "Directory ${directory@Q} does not exist."

  # Apply search depth limitation if specified
  ((maxdepth < 0)) || rg_opts+=(--max-depth "$maxdepth")

  # Convert excluded directories to ripgrep glob patterns
  for exclude_dir in "${EXCLUDE_DIRS[@]}"; do
    [[ -z "$exclude_dir" ]] || rg_opts+=(--glob "!$exclude_dir/**")
  done

  # Debug output
  ((DEBUG)) && { 
    debug "DEBUG: RG_CMD=$RG_CMD" \
      "RG_TYPE=$RG_TYPE" \
      "pattern=$pattern" \
      "directory=$directory" \
      "exclude_dirs=${EXCLUDE_DIRS[*]}" \
      "ripgrep options: ${rg_opts[*]}"
  }

  # Execute search using the optimal available method
  if [[ "$RG_CMD" == "grep_fallback" ]]; then
    # Use fallback implementation with advanced file detection when ripgrep is unavailable
    run_grep_fallback "$pattern" "$directory" "$maxdepth" "${rg_opts[@]}"
  else
    # Use hybrid approach: comprehensive file detection + ripgrep search performance
    local -- mode_filter
    case "$SCRIPT_NAME" in
      phpgrep) mode_filter=php ;;
      bashgrep) mode_filter=bash ;;
      pygrep) mode_filter=python ;;
      *) mode_filter=all ;;
    esac
    
    # Phase 1: Find all matching files using comprehensive detection (extension + shebang)
    local -a matching_files=()
    while IFS= read -r -d '' file; do
      matching_files+=("$file")
    done < <(find_matching_files "$directory" "$mode_filter" "$maxdepth" "${EXCLUDE_DIRS[@]}" | tr '\n' '\0')
    
    # If no files found, exit early with appropriate message
    ((${#matching_files[@]})) || {
      warn "No $MODE files found in ${directory@Q}"
      return 1
    }
    
    # Phase 2: Clean ripgrep options for file-based search
    local -a clean_rg_opts=()
    while IFS= read -r opt; do
      [[ -z "$opt" ]] || clean_rg_opts+=("$opt")
    done < <(clean_rg_options_for_files "${rg_opts[@]}")
    
    # Phase 3: Use ripgrep to search within the filtered files for maximum performance
    ((DEBUG)) && {
      debug "Hybrid mode - found ${#matching_files[@]} matching files"
      debug "clean_rg_opts=${clean_rg_opts[*]}"
    }
    
    # Handle large file lists by chunking if necessary (avoid argument length limits)
    local -i chunk_size=100
    local -i start=0
    local -i found_matches=0
    
    local -a chunk
    while ((start < ${#matching_files[@]})); do
      chunk=("${matching_files[@]:$start:$chunk_size}")
      
      if "$RG_CMD" "${clean_rg_opts[@]}" "$pattern" "${chunk[@]}"; then
        found_matches=1
      fi
      
      start+=chunk_size
    done
    
    # Exit with appropriate code based on whether matches were found
    ((found_matches)) && return 0
    warn "No $MODE files found with pattern ${pattern@Q}"
    return 1
  fi
}

main "$@"
#fin
